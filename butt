#!/bin/bash

#shopt -s nocasematch
shopt -s extglob
set -u

# shellcheck disable=SC2086
: ${BUTT_DATAPATH:=.}
# shellcheck disable=SC2086
: ${BUTT_OPTIONS:=}
: ${COLUMNS:=$(tput cols)}
: ${LINES:=$(tput lines)}

function main {

  function msg_start {
    if stdoutpipe || [[ $COLUMNS -lt 41 ]]; then
      echo "$1" && return 0
    fi
    echo -n "[ "
    save_cursor_position
    echo " ....  ] $1"
  }

  function msg_end {
    if stdoutpipe || [[ $COLUMNS -lt 41 ]]; then
      echo "[ $1 ]" && return 0
    fi
    set_cursor_position
    echo "$1"
  }

  function stdout_silent {
    [[ $verbose == 0 ]] && exec 5<&1 && exec 1>/dev/null
    return 0
  }

  function stdout_verbose {
    [[ $verbose == 0 ]] && exec 1<&5
    return 0
  }

  function err {
    echo "$(basename "${0}")[error]: $*" >&2
    return 1
  }

  function setcolor {
    local c
    c=${1:-always}
    case $c in
      always|never|auto)
        color=$c
        return 0
      ;;
    esac
    return 2
  }

  function stdoutpipe {
    readlink /proc/$$/fd/1 | grep -q "^pipe:"
  }

  function colorize {
    [[ $color == never ]] && echo -n "$1" && return
    [[ $color == auto ]] && stdoutpipe && echo -n "$1" && return
    local c
    c="${2:-$GREEN}"
    tput setaf "$c"
    echo -n "$1"
    tput sgr0
  }

  function clear_stdin {
    while read -r -t 0; do read -r; done
  }

  function save_cursor_position {
    local curpos
    curpos="1;1"
    echo -en "\033[6n" >/dev/tty
    # shellcheck disable=SC2162
    read -d"R" curpos </dev/tty
    pos_x=$( echo "${curpos#??}" | cut -d";" -f1 )
    pos_y=$( echo "${curpos#??}" | cut -d";" -f2 )
  }

  function set_cursor_position {
    [[ "$pos_x" == "$LINES" ]] && : $(( pos_x-- ))
    tput cup $(( pos_x-1 )) $(( pos_y-1 ))
  }

  function confirm {
    if [[ $is_stdin == 0 ]]; then
      stdout_verbose
      echo -n "${1:-"Are you sure?"} [YES/No] "
      save_cursor_position
      clear_stdin
      read -r
      [[ -z "$REPLY" ]] && set_cursor_position && echo "yes"
      stdout_silent
    else
      read -r
    fi
    [[ "$REPLY" =~ ^y(es)?$ || -z "$REPLY" ]] && return 0
    [[ "$REPLY" =~ ^no?$ ]] && return 1
    confirm "Type"
  }

  function usage {
    local usage_file shift_left
    usage_file="$BUTT_DATAPATH/${script_name}.usage"
    [ -f "$usage_file" ] \
      || err "Usage file not found" \
      || return 1
    head -n1 "$usage_file"
    echo
    shift_left=0
    # shellcheck disable=SC2004
    [[ $COLUMNS -gt 1 ]] && shift_left=5 && export MANWIDTH=$((COLUMNS+$shift_left))
    # shellcheck disable=SC2005
    echo "$(tail -n+2 "$usage_file")" | man --nj --nh -l - | sed "1,2d;/^[[:space:]]*$/d;\$d;s/^ \{$shift_left\}//"
  }

  function version {
    local ver
    ver="$BUTT_DATAPATH/VERSION"
    [ -f "$ver" ] \
      || err "Version file not found" \
      || return 1
    echo -n "GNU gf "
    cat "$ver"
  }

  function msg_end_status {
    local status
    status="${1-}"
    # shellcheck disable=SC2015
    [ "$status" -eq 0 ] \
      && msg_end "$DONE" \
      || msg_end "$FAILED"
  }

  function status {
    msg_start "${FUNCNAME[1]}"
    msg_end_status "$1"
    if [[ ! $1 -eq 0 ]]; then
      : $((failed++))
    fi
    return "$1"
  }
  function assert_equal {
    [[ "$1" == "$2" ]]
    status $?
  }
  function assert_startwith {
    [[ "$1" == "$2"* ]]
    status $?
  }
  function assert_contains {
    echo "$1" | grep -q "$2"
    status $?
  }

  function eval_cmd {
    local cmd
    cmd="${2-}"
    case "$1" in
      test) test_header "$2";;
      run|before|after)
        local stdoutfile stderrfile
        stdoutfile="$(mktemp)"
        stderrfile="$(mktemp)"
        eval "$cmd" > "$stdoutfile" 2>"$stderrfile"
        status=$?\
        stdout="$(< "$stdoutfile")"
        stderr="$(< "$stderrfile")"
        if [[ "$1" == "before" || "$1" == "after" ]]; then
          [[ -n "$stdout" ]] && echo "$stdout"
          # shellcheck disable=SC2005
          [[ -n "$stderr" ]] && echo "$(colorize "$stderr" "$RED")"
        fi
        IFS=$'\n' read -d '' -r -a outlines <<< "$stdout"
        IFS=$'\n' read -d '' -r -a errlines <<< "$stderr"
        ;;
      start|eval|end) eval "$cmd";;
    esac
  }

  function test_header {
    stdout_verbose
    echo "# test '$1'"
    stdout_silent
  }

  function validate {
    [ ${#@} -eq 1 ] \
      || err "Invalid number of arguments" \
      || { usage; return 2; }
    [ -f "$1" ] \
      || err "File '$1' not found" \
      || return 1
  }

  ##
  # start
  # test
  # before
  # run
  # eval
  # after
  # end
  function process {
    local state prev_state input state_changed linen
    state=
    prev_state=
    input=
    linen=0
    state_changed=0
    last_linen=$(< "$1" wc -l)
    while IFS= read -r line; do
      : $((linen++))
      [[ -z "$line" ]] && continue

      # set state
      state_changed=0
      case "$line" in
        \#test*|\#start*|\#before*|\#run*|\#eval*|\#after*|\#end*)
          prev_state="$state"
          state="$(echo "$line" | cut -d" " -f1)"
          state="${state#\#}"
          state_changed=1
          ;;
      esac

      # process input
      if [[ $state_changed -eq 0 ]] || [[ $linen -eq $last_linen ]]; then
        [[ -n "$input" ]] && line=$'\n'"$line"
        input="$input$line"
      fi

      # state changed or it last line
      if [[ $state_changed -eq 1 ]] || [[ $linen -eq $last_linen ]]; then
        eval_cmd "$prev_state" "$input"
        input=
      fi

    done < "$1"
  }

  local line script_name pos_x pos_y is_stdin status failed
  # shellcheck disable=SC2034
  local stdout stderr outlines errlines

  script_name="butt"
  color=auto
  pos_x=1
  pos_y=1
  failed=0
  [ -t 0 ]
  is_stdin=$?

  # process options
  # shellcheck disable=SC2086
  # shellcheck disable=SC2048
  if ! line=$(
    IFS=" " getopt -n "$0" \
           -o chvV\? \
           -l color::,colour::,help,verbose,version \
           -- $BUTT_OPTIONS $*
  )
  then usage; return 2; fi
  eval set -- "$line"

  # load user options
  verbose=0
  while [ $# -gt 0 ]; do
    case $1 in
      --color|--colour) shift; setcolor "$1" || { usage; return 2; }; shift ;;
      -h|-\?|--help) usage; return $? ;;
      -v|--verbose) verbose=1; shift ;;
      -V|--version) version; return $? ;;
      --) shift; break ;;
      *-) err "Unrecognized option '$1'"; usage; return 2 ;;
      *) break ;;
    esac
  done

  # silent if not verbose
  [ $verbose -eq 0 ] && stdout_silent

  # constants
  local -r \
    RED=1 \
    GREEN=2 \
    BLUE=4
  # shellcheck disable=SC2034
  local -r \
    DONE="$(colorize "  ok  " $GREEN)" \
    FAILED="$(colorize "failed" $RED)" \
    SKIPPED="$(colorize "skipped" $BLUE)"

  # run butt
  # shellcheck disable=SC2015
  validate "$@" && process "$@" || {
    case $? in
      1) err "Generic error occurred."; return 1 ;;
    esac
  }

}

main "$@"